//
//  cx_time.c
//
//  Created by Ubaka Onyechi on 10/01/2012.
//  Copyright (c) 2012 uonyechi.com. All rights reserved.
//

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "cx_time.h"
#include <mach/mach.h>
#include <mach/mach_time.h>
#include <unistd.h>

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

struct cx_sys_time
{
  uint64_t prevTime;
  cxf64 deltaTime;
  cxf64 totalTime;
  bool update;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

static struct cx_sys_time s_systemTime;
static mach_timebase_info_data_t s_timebase;

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

void cx_system_time_start (void)
{
  //struct timeval t;
  //gettimeofday (&t, NULL);  
  //s_systemTime.prevTime = ((uint64_t) t.tv_sec * 1000000) + (uint64_t) t.tv_usec; // microseconds
  
  mach_timebase_info (&s_timebase);
  s_systemTime.prevTime = mach_absolute_time ();
  s_systemTime.deltaTime = 0.0f;
  s_systemTime.totalTime = 0.0f;
  s_systemTime.update = true;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

void cx_system_time_update (void)
{
  //struct timeval t;
  //gettimeofday (&t, NULL);  
  //u_int64_t currentTime = ((uint64_t) t.tv_sec * 1000000) + (uint64_t) t.tv_usec;
  
  u_int64_t currentTime = mach_absolute_time ();
  u_int64_t deltaTime = currentTime - s_systemTime.prevTime;
  s_systemTime.prevTime = currentTime;
  
  if (s_systemTime.update)
  {
    // microseconds to seconds
    //s_systemTime.deltaTime = (cxf64) deltaTime / (1000000.0f);
    //s_systemTime.totalTime += s_systemTime.deltaTime;
  
    // nanoseconds to seconds 
    s_systemTime.deltaTime = (cxf64) deltaTime * (cxf64) s_timebase.numer / (cxf64) s_timebase.denom / 1e9;
    s_systemTime.totalTime += s_systemTime.deltaTime;
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

void cx_system_time_pause (bool pause)
{
  s_systemTime.update = !pause;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

cxf64 cx_system_time_get_delta_time (void)
{
  return s_systemTime.deltaTime;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

cxf64 cx_system_time_get_total_time (void)
{
  return s_systemTime.totalTime;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

time_t cx_time_get_utc_time (void)
{
  time_t rawTime = time (NULL);
  CX_ASSERT (rawTime != -1);
  
  struct tm *gmt = gmtime (&rawTime);
  
  time_t utcTime = mktime (gmt);
  CX_ASSERT (utcTime != -1);
  
  return utcTime;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

cxi32 cx_time_get_utc_offset (void)
{
  time_t rawTime = time (NULL);
  
  struct tm utcTm = *gmtime (&rawTime);
  struct tm locTm = *localtime (&rawTime);
  
  time_t utcTime = mktime (&utcTm);
  time_t locTime = mktime (&locTm);
  
  double diffSecs = difftime (locTime, utcTime);
  cxi32 diffHr = (cxi32) (diffSecs / (60.0f * 60.0f));
  
  return diffHr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////


void cx_timer_start (cx_timer *timer)
{
  CX_ASSERT (timer);
  
  timer->elapsedTime = 0.0f;
  timer->active = true;
  timer->startTime = mach_absolute_time ();
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

void cx_timer_stop (cx_timer *timer)
{
  CX_ASSERT (timer);
  
  // Reference: http://developer.apple.com/library/mac/#qa/qa1398/_index.html
  
  if (timer->active)
  {
    uint64_t endTime = mach_absolute_time ();
    
    uint64_t elapsed = endTime - timer->startTime;
    
    // convert to milliseconds
    
    mach_timebase_info_data_t timebase;
    
    mach_timebase_info (&timebase);
    
    timer->elapsedTime = ((cxf64) elapsed * (cxf64) timebase.numer / (cxf64) timebase.denom) / 1e6;
    
    timer->active = false;
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

void cx_timer_reset (cx_timer *timer)
{
  CX_ASSERT (timer);
  
  timer->startTime = 0;
  timer->elapsedTime = 0.0f;
  timer->active = false;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
