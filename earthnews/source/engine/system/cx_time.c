//
//  cx_time.c
//
//  Created by Ubaka Onyechi on 10/01/2012.
//  Copyright (c) 2012 uonyechi.com. All rights reserved.
//

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "cx_time.h"
#include "cx_thread.h"
#include "cx_string.h"
#include <mach/mach.h>
#include <mach/mach_time.h>
#include <unistd.h>

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

struct cx_sys_time
{
  uint64_t prevTime;
  cxf64 deltaTime;
  cxf64 totalTime;
  bool update;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

static struct cx_sys_time g_systemTime;
static cx_thread_mutex g_criticalSection; // for thread-unsafe and non-reentrant crt time functions
static mach_timebase_info_data_t g_timebase;

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

void cx_system_time_init (void)
{
  cx_thread_mutex_init (&g_criticalSection);
  
  //struct timeval t;
  //gettimeofday (&t, NULL);  
  //g_systemTime.prevTime = ((uint64_t) t.tv_sec * 1000000) + (uint64_t) t.tv_usec; // microseconds
  
  mach_timebase_info (&g_timebase);
  g_systemTime.prevTime = mach_absolute_time ();
  g_systemTime.deltaTime = 0.0f;
  g_systemTime.totalTime = 0.0f;
  g_systemTime.update = true;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

void cx_system_time_update (void)
{
  //struct timeval t;
  //gettimeofday (&t, NULL);  
  //u_int64_t currentTime = ((uint64_t) t.tv_sec * 1000000) + (uint64_t) t.tv_usec;
  
  u_int64_t currentTime = mach_absolute_time ();
  u_int64_t deltaTime = currentTime - g_systemTime.prevTime;
  g_systemTime.prevTime = currentTime;
  
  if (g_systemTime.update)
  {
    // microseconds to seconds
    //g_systemTime.deltaTime = (cxf64) deltaTime / (1000000.0f);
    //g_systemTime.totalTime += g_systemTime.deltaTime;
  
    // nanoseconds to seconds 
    g_systemTime.deltaTime = (cxf64) deltaTime * (cxf64) g_timebase.numer / (cxf64) g_timebase.denom / 1e9;
    g_systemTime.totalTime += g_systemTime.deltaTime;
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

void cx_system_time_pause (bool pause)
{
  g_systemTime.update = !pause;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

cxf64 cx_system_time_get_delta_time (void)
{
  return g_systemTime.deltaTime;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

cxf64 cx_system_time_get_total_time (void)
{
  return g_systemTime.totalTime;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

void cx_system_sleep (cxu32 msecs)
{
  cxu32 usecs = msecs * 1000;
  
  usleep (usecs);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

cxi64 cx_time_get_utc_epoch (void)
{
  cxi64 timestamp = 0;
  
  cx_thread_mutex_lock (&g_criticalSection);
  
  time_t rawTime = time (NULL);
  CX_ASSERT (rawTime != -1);
  
  struct tm gmt = *gmtime (&rawTime);
  time_t utcTime = timegm (&gmt);
  CX_ASSERT (utcTime != -1);
  
  timestamp = (cxi64) utcTime;
  
  cx_thread_mutex_unlock (&g_criticalSection);
  
  return timestamp;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

cxi32 cx_time_get_utc_offset (void)
{
  cx_thread_mutex_lock (&g_criticalSection);
  
  time_t rawTime = time (NULL);
  CX_ASSERT (rawTime != -1);

  struct tm locTm = *localtime (&rawTime);
  
#if 1
  cxi32 diffSecs = locTm.tm_gmtoff;
#else
  struct tm utcTm = *gmtime (&rawTime);
  time_t utcTime = timegm (&utcTm);
  time_t locTime = timegm (&locTm);
  cxi32 diffSecs = (cxi32) difftime (locTime, utcTime);
#endif
  
  cxi32 offsetMin = (diffSecs / 60) % 60;
  cxi32 offsetHr = (diffSecs / 3600) * 100;
  cxi32 offset = offsetHr + offsetMin;
  
  cx_thread_mutex_unlock (&g_criticalSection);
  
  return offset;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
#if 0
cxi32 cx_time_get_dst_offset_tz (const char *tzabv)
{
  cxi32 dstOffset = 0;
  
  char *env = getenv ("TZ");
  
  if (env)
  {
    char tzprev [32];
  
    cx_sprintf (tzprev, 32, "%s", env);
    
    setenv ("TZ", tzabv, 1);
    tzset ();
    
    time_t rawTime = time (NULL);
    CX_ASSERT (rawTime != -1);
    
    struct tm tzLocaltime = *localtime (&rawTime);
    
    dstOffset = tzLocaltime.tm_isdst;
    
    setenv ("TZ", tzprev, 1);
    tzset ();
  }
  else
  {
    setenv ("TZ", tzabv, 1);
    tzset ();
    
    time_t rawTime = time (NULL);
    CX_ASSERT (rawTime != -1);
    
    struct tm tzLocaltime = *localtime (&rawTime);
    dstOffset = tzLocaltime.tm_isdst;
    
    unsetenv ("TZ");
    tzset ();
  }
  
  return dstOffset;
}
#endif
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

cxi32 cx_time_get_dst_offset_2015 (cx_time_dst dst)
{
  cxi32 dstOffset = 0;
  
  cx_date date;
  cx_time_set_date (&date, CX_TIME_ZONE_UTC);

  switch (dst)
  {
    case CX_TIME_DST_EUR:
    {
      int yr = date.calendar.tm_year;
      int mo = date.calendar.tm_mon;
      int dy = date.calendar.tm_mday;
      int hr = date.calendar.tm_hour;
      
      int beginMon = 2; // march
      int endMon = 9; // october
      
      if (mo == beginMon)
      {
        int a = ((((5 * yr) / 4) + 4) % 7);
        int beginDay = 31 - a;
        
        if (dy >= beginDay)
        {
          dstOffset = 1;
        }
        else if (dy == beginDay)
        {
          if (hr >= 1)
          {
            dstOffset = 1;
          }
        }
      }
      else if (mo == endMon)
      {
        int b = ((((5 * yr) / 4) + 1) % 7);
        int endDay = 31 - b;
        
        if (dy < endDay)
        {
          dstOffset = 1;
        }
        else if (dy == endDay)
        {
          if (hr < 1)
          {
            dstOffset = 1;
          }
        }
      }
      else if ((mo > beginMon) && (mo < endMon))
      {
        dstOffset = 1;
      }
      
      dstOffset *= 100;
      
      break;
    }
      
    default:
    {
      break;
    }
  }
  
  return dstOffset;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

void cx_time_set_date (cx_date *date, cx_time_zone zone)
{
  CX_ASSERT (date);
  CX_ASSERT ((zone > CX_TIME_ZONE_INVALID) && (zone < CX_NUM_TIME_ZONES));
  
  cx_thread_mutex_lock (&g_criticalSection); // gmtime not reentrant
  
  switch (zone) 
  {
    case CX_TIME_ZONE_LOCAL:
    {
      time_t rawTime = time (NULL);
      date->calendar = *localtime (&rawTime);
      date->epochTime = (cxi64) mktime (&date->calendar);
      
      break;
    }
      
    case CX_TIME_ZONE_UTC:
    {
      time_t rawTime = time (NULL);
      date->calendar = *gmtime (&rawTime);
      date->epochTime = (cxi64) timegm (&date->calendar);
      
      break;
    }
      
    default:
    {
      date->epochTime = 0;
      
      break;
    }
  }
  
  cx_thread_mutex_unlock (&g_criticalSection);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

void cx_time_start_timer (cx_timer *timer)
{
  CX_ASSERT (timer);
  
  timer->elapsedTime = 0.0f;
  timer->active = true;
  timer->startTime = mach_absolute_time ();
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

void cx_time_stop_timer (cx_timer *timer)
{
  CX_ASSERT (timer);
  
  // Reference: http://developer.apple.com/library/mac/#qa/qa1398/_index.html
  
  if (timer->active)
  {
    uint64_t endTime = mach_absolute_time ();
    
    uint64_t elapsed = endTime - timer->startTime;
    
    // convert to milliseconds
    
    mach_timebase_info_data_t timebase;
    
    mach_timebase_info (&timebase);
    
    timer->elapsedTime = ((cxf64) elapsed * (cxf64) timebase.numer / (cxf64) timebase.denom) / 1e6;
    
    timer->active = false;
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

void cx_time_reset_timer (cx_timer *timer)
{
  CX_ASSERT (timer);
  
  timer->startTime = 0;
  timer->elapsedTime = 0.0f;
  timer->active = false;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
