//
//  cx_json.c
//
//  Copyright (c) 2012 Ubaka Onyechi. All rights reserved.
//

#include "cx_json.h"
#include "cx_string.h"
#include "../3rdparty/json-parser/json.h"

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

#define CX_JSON_DEBUG_LOG_ENABLED (CX_DEBUG && 1)

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

typedef struct
{
  json_value *root;
} cx_json_tree_internal;

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

cx_json_tree cx_json_tree_create (const char *data, cxu32 size)
{
  CX_ASSERT (data);
  
  cx_json_tree_internal *tree = NULL;
  
  json_settings settings;
  
  memset (&settings, 0, sizeof(settings));
  
  char errorBuffer [512];
  
  json_value *root = json_parse_ex (&settings, data, size, errorBuffer, 512);
  
  if (root)
  {
    tree = cx_malloc (sizeof (cx_json_tree_internal));
    
    tree->root = root;
  }
  
  CX_LOG_CONSOLE (CX_JSON_DEBUG_LOG_ENABLED && (root == NULL), errorBuffer);
  
  return tree;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

void cx_json_tree_destroy (cx_json_tree tree)
{
  CX_ASSERT (tree);
  
  cx_json_tree_internal *t = (cx_json_tree_internal *) tree;
  
  json_value_free (t->root);
  
  cx_free (t);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

cx_json_node cx_json_tree_root_node (cx_json_tree tree)
{
  CX_ASSERT (tree);
  
  cx_json_tree_internal *t = (cx_json_tree_internal *) tree;
  
  return t->root;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

cx_json_type cx_json_node_type (cx_json_node node)
{
  CX_ASSERT (node);
  
  json_value *jnode = node;
  
  switch (jnode->type) 
  {
    case json_boolean:  { return CX_JSON_TYPE_BOOL; }
    case json_integer:  { return CX_JSON_TYPE_INT; }
    case json_double:   { return CX_JSON_TYPE_FLOAT; }
    case json_string:   { return CX_JSON_TYPE_STRING; }
    case json_object:   { return CX_JSON_TYPE_OBJECT; }
    case json_array:    { return CX_JSON_TYPE_ARRAY; }
    default:            { return CX_JSON_TYPE_INVALID; }
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

cx_json_node cx_json_object_child (cx_json_node node, const char * CX_RESTRICT key)
{
  CX_ASSERT (node);
  CX_ASSERT (key);
  CX_ASSERT (cx_json_node_type (node) == CX_JSON_TYPE_OBJECT);
  
  json_value *jnode = node;
  json_value *jchild = NULL;
  
  for (cxu32 i = 0, c = jnode->u.object.length; i < c; ++i)
  {
    const char *n = jnode->u.object.values [i].name;
    
    if (strcmp (key, n) == 0)
    {
      jchild = jnode->u.object.values [i].value;
      break;
    }
  }
  
  return jchild;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

cx_json_node cx_json_object_child_node (cx_json_node node, cxu32 index)
{
  CX_ASSERT (node);
  CX_ASSERT (cx_json_node_type (node) == CX_JSON_TYPE_OBJECT);
  
  json_value *jnode = node;
  
  CX_ASSERT (index < jnode->u.object.length);
  
  json_value *jchild = jnode->u.object.values [index].value;
  
  return jchild;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

const char * cx_json_object_child_key (cx_json_node node, cxu32 index)
{
  CX_ASSERT (node);
  CX_ASSERT (cx_json_node_type (node) == CX_JSON_TYPE_OBJECT);
  
  json_value *jnode = node;
  
  CX_ASSERT (index < jnode->u.object.length);
  
  const char *key = jnode->u.object.values [index].name;
  
  return key;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

cxu32 cx_json_object_length (cx_json_node node)
{
  CX_ASSERT (node);
  CX_ASSERT (cx_json_node_type (node) == CX_JSON_TYPE_OBJECT);
  
  json_value *jnode = node;
  
  cxu32 len = jnode->u.object.length;
  
  return len;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

cx_json_node cx_json_array_member (cx_json_node node, cxu32 index)
{
  CX_ASSERT (node);
  CX_ASSERT (cx_json_node_type (node) == CX_JSON_TYPE_ARRAY);
  
  json_value *jnode = node;
  
  CX_ASSERT (index < jnode->u.array.length);
  
  json_value *jchild = jnode->u.array.values [index];
  
  return jchild;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

cxu32 cx_json_array_size (cx_json_node node)
{
  CX_ASSERT (node);
  CX_ASSERT (cx_json_node_type (node) == CX_JSON_TYPE_ARRAY);
  
  json_value *jnode = node;
  
  cxu32 size = jnode->u.array.length;
  
  return size;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

const char *cx_json_value_string (cx_json_node node)
{
  CX_ASSERT (node);
  CX_ASSERT (cx_json_node_type (node) == CX_JSON_TYPE_STRING);
  
  json_value *jnode = node;
  
  const char *str = jnode->u.string.ptr;
  
  return str;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

cxi64 cx_json_value_int (cx_json_node node)
{
  CX_ASSERT (node);
  CX_ASSERT (cx_json_node_type (node) == CX_JSON_TYPE_INT);
  
  json_value *jnode = node;
  
  cxi64 i = (cxi64) jnode->u.integer;
  
  return i;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

cxf32 cx_json_value_float (cx_json_node node)
{
  CX_ASSERT (node);
  CX_ASSERT (cx_json_node_type (node) == CX_JSON_TYPE_FLOAT);
  
  json_value *jnode = node;
  
  float f = (float) jnode->u.dbl;
  
  return f;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

bool cx_json_value_bool (cx_json_node node)
{
  CX_ASSERT (node);
  CX_ASSERT (cx_json_node_type (node) == CX_JSON_TYPE_BOOL);
  
  json_value *jnode = node;
  
  bool b = (bool) jnode->u.boolean;
  
  return b;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
