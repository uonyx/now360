//
//  cx_file.c
//
//  Created by Ubaka Onyechi on 02/01/2012.
//  Copyright (c) 2012 uonyechi.com. All rights reserved.
//

#include "cx_file.h"
#include "cx_string.h"
#include "cx_native_ios.h"

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

#define CX_FILE_MAX_FILE_PATHNAME 512

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

bool cx_file_open (cx_file *file, const char *filename, cxu32 mode)
{
  CX_ASSERT (file);
  CX_ASSERT (filename);
  CX_ASSERT ((mode >= 0) && (mode < CX_FILE_NUM_MODES));
  
  static const char *modes [CX_FILE_NUM_MODES] = 
  {
    "rb",
    "wb",
    "ab",
  };
  
  const char *m = modes [mode];

  *file = fopen (filename, m);

  return (*file != NULL);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

bool cx_file_close (cx_file *file)
{
  int err = fclose (*file);
  
  *file = NULL;
  
  return (err == 0);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

cxu32 cx_file_read (cx_file *file, void *buffer, cxu32 size, cxu32 count)
{
  CX_ASSERT (file);
  
  return fread (buffer, size, count, *file);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

cxu32 cx_file_write (cx_file *file, const void *buffer, cxu32 size, cxu32 count)
{
  CX_ASSERT (file);
  
  return fwrite (buffer, size, count, *file);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

cxi32 cx_file_flush (cx_file *file)
{
  CX_ASSERT (file);
  
  return fflush (*file);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

cxi32 cx_file_seek (cx_file *file, cxi32 offset, cxi32 origin)
{
  CX_ASSERT (file);
  
  return fseek (*file, offset, origin);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

cxu32 cx_file_size (cx_file *file)
{
  CX_ASSERT (file);
  
  fseek (*file, 0L, SEEK_END);
  
  cxu32 size = (cxu32) ftell (*file);
  
  fseek (*file, 0L, SEEK_SET);
  
  return size;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

void cx_file_storage_path (char *dstpath, int dstpathSize, const char *filename, cx_file_storage_base base)
{
  CX_ASSERT (filename);
  CX_ASSERT (dstpath);
  CX_ASSERT (dstpathSize > 0);
  
  switch (base) 
  {
    case CX_FILE_STORAGE_BASE_RESOURCE:
    {
      cx_native_file_get_resource_path (dstpath, dstpathSize);
      break;
    }
      
    case CX_FILE_STORAGE_BASE_DOCUMENTS:
    {
      cx_native_file_get_documents_path (dstpath, dstpathSize);
      break;
    }
      
    case CX_FILE_STORAGE_BASE_CACHE:
    {
      cx_native_file_get_cache_path (dstpath, dstpathSize);
      break;
    }
      
    default:
    {
      dstpath [0] = 0;
      break;
    }
  }

  cx_strcat (dstpath, dstpathSize, "/");
  cx_strcat (dstpath, dstpathSize, filename);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

bool cx_file_storage_exists (const char *filename, cx_file_storage_base base)
{
  CX_ASSERT (filename);
  
  bool exists = false;
  
  char storagePath [CX_FILE_MAX_FILE_PATHNAME];
  
  cx_file_storage_path (storagePath, CX_FILE_MAX_FILE_PATHNAME, filename, base);
  
  cx_file file;
  
  if (cx_file_open (&file, storagePath, CX_FILE_MODE_READ))
  {
    cx_file_close (&file);
    
    exists = true;
  }
  
  return exists;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

bool cx_file_storage_load_contents (cxu8 **buffer, cxu32 *size, const char *filename, cx_file_storage_base base)
{
  CX_ASSERT (filename);
  
  bool loaded = false;
  
  char storagePath [CX_FILE_MAX_FILE_PATHNAME];
  
  cx_file_storage_path (storagePath, CX_FILE_MAX_FILE_PATHNAME, filename, base);
  
  cx_file file;
  
  if (cx_file_open (&file, storagePath, CX_FILE_MODE_READ))
  {
    cxu32 sz = cx_file_size (&file);
    cxu8 *buf = cx_malloc (sizeof (cxu8) * (sz + 1));
    cxu32 read = cx_file_read (&file, buf, sizeof (cxu8), sz);
    
    CX_ASSERT (read == sz);
    CX_REFERENCE_UNUSED_VARIABLE (read);
    
    buf [sz] = 0;
  
    *buffer = buf;
    *size = sz;
    
    cx_file_close (&file);
    
    loaded = true;
  }
  
  return loaded;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

bool cx_file_storage_save_contents (const cxu8 *buffer, cxu32 size, const char *filename, cx_file_storage_base base)
{
  CX_ASSERT (filename);
  CX_ASSERT (buffer);
  
  bool saved = false;
  
  char storagePath [CX_FILE_MAX_FILE_PATHNAME];
  
  cx_file_storage_path (storagePath, CX_FILE_MAX_FILE_PATHNAME, filename, base);
  
  cx_file file;
  
  if (cx_file_open (&file, storagePath, CX_FILE_MODE_WRITE))
  {
    cxu32 written = cx_file_write (&file, buffer, sizeof (cxu8), size);
    
    CX_ASSERT (written == size);
    CX_REFERENCE_UNUSED_VARIABLE (written);
    
    cx_file_close (&file);
    
    saved = true;
  }
  
  return saved;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

bool cx_file_storage_create_dir (const char *dirname, cx_file_storage_base base);

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

bool cx_file_storage_delete (const char *dirname, cx_file_storage_base base);

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

bool cx_file_storage_copy (const char *tofilename, cx_file_storage_base tobase, 
                           const char *frmfilename, cx_file_storage_base frmbase);

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

bool cx_file_storage_move (const char *tofilename, cx_file_storage_base tobase, 
                           const char *frmfilename, cx_file_storage_base frmbase);

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
