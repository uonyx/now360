//
//  cx_graphics.c
//
//  Created by Ubaka Onyechi on 01/01/2012.
//  Copyright (c) 2012 uonyechi.com. All rights reserved.
//

#include <OpenGLES/ES2/gl.h>
#include <OpenGLES/ES2/glext.h>

#include "cx_gdi.h"
#include "cx_file.h"
#include "cx_string.h"
#include "cx_shader.h"
#include "cx_material.h"
#include "cx_mesh.h"
#include "cx_draw.h"

#include "../system/cx_native_ios.h"

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

#define CX_GDI_DEFAULT_SCREEN_WIDTH     1280
#define CX_GDI_DEFAULT_SCREEN_HEIGHT    720

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

typedef struct cx_gdi_extension_info
{
  const char *name;
  bool supported;
} cx_gdi_extension_info;

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

static bool g_initialised = false;

static cxi32 g_screenWidth = 0;
static cxi32 g_screenHeight = 0;

static cx_gdi_renderstate g_activeRenderstate = CX_GDI_RENDER_STATE_NONE;
static GLenum g_openglBlendModes [CX_NUM_GDI_BLEND_MODES] =
{
  GL_SRC_ALPHA,
  GL_ONE_MINUS_SRC_ALPHA,
};

static cx_mat4x4 g_transforms [CX_NUM_GDI_TRANSFORMS];
static cx_gdi_extension_info g_extensionInfoArray [CX_NUM_GDI_EXTENSIONS] =
{
  { "GL_IMG_texture_compression_pvrtc", false }, //CX_GDI_EXTENSION_PVRTC,
  { "GL_ARB_texture_non_power_of_two", false }   //CX_GDI_EXTENSION_NPOT,
};

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

static void cx_gdi_init_extensions (void);

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

bool _cx_gdi_init (void *ctx, cxi32 w, cxi32 h)
{
  CX_ASSERT (!g_initialised);
  CX_ASSERT (ctx);

  cx_native_eagl_context_init (ctx);
  
  cx_mat4x4_identity (&g_transforms [CX_GDI_TRANSFORM_P]);
  cx_mat4x4_identity (&g_transforms [CX_GDI_TRANSFORM_MV]);
  cx_mat4x4_identity (&g_transforms [CX_GDI_TRANSFORM_MVP]);

  cx_gdi_init_extensions ();
  cx_gdi_set_screen_dimensions (w, h);

  g_initialised = true;
  
  return g_initialised;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

bool _cx_gdi_deinit (void)
{
  if (g_initialised)
  {
    cx_native_eagl_context_deinit ();
  
    g_initialised = false;
  }
  
  return !g_initialised;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

void cx_gdi_shared_context_create (void)
{
  CX_ASSERT (g_initialised);
  
  cx_native_eagl_context_add ();
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

void cx_gdi_shared_context_destroy (void)
{
  CX_ASSERT (g_initialised);
  
  cx_native_eagl_context_remove ();
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

bool cx_gdi_get_extension_supported (cx_gdi_extension extension)
{
  CX_ASSERT (g_initialised);
  CX_ASSERT ((extension > CX_GDI_EXTENSION_INVALID) && (extension < CX_NUM_GDI_EXTENSIONS));
  
  bool supported = g_extensionInfoArray [extension].supported;
  
  return supported;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

cxf32 cx_gdi_get_aspect_ratio (void)
{
  CX_ASSERT (g_initialised);
  CX_ASSERT (g_screenWidth > 0);
  
  cxf32 aspectRatio = (cxf32) g_screenWidth / (cxf32) g_screenHeight;
  
  return aspectRatio;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

cxf32 cx_gdi_get_screen_width (void)
{
  CX_ASSERT (g_initialised);
  return (float) g_screenWidth;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

cxf32 cx_gdi_get_screen_height (void)
{
  CX_ASSERT (g_initialised);
  return (float) g_screenHeight;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

void cx_gdi_set_transform (cx_gdi_transform transform, const cx_mat4x4 *matrix)
{
  CX_ASSERT (g_initialised);
  CX_ASSERT ((transform >= 0) && (transform < CX_NUM_GDI_TRANSFORMS));
  CX_ASSERT (matrix);
  
  g_transforms [transform] = *matrix;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

void cx_gdi_get_transform (cx_gdi_transform transform, cx_mat4x4 *matrix)
{
  CX_ASSERT (g_initialised);
  CX_ASSERT ((transform >= 0) && (transform < CX_NUM_GDI_TRANSFORMS));
  CX_ASSERT (matrix);
  
  *matrix = g_transforms [transform];
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

void cx_gdi_set_screen_dimensions (cxi32 width, cxi32 height)
{
  CX_LOG_CONSOLE (CX_GDI_DEBUG_LOG_ENABLED, "cx_gdi_set_screen_dimensions: width [%d], height [%d]", width, height);
  
  g_screenWidth = width;
  g_screenHeight = height;
  
  glViewport (0, 0, width, height);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

void cx_gdi_set_viewport (cxi32 width, cxi32 height)
{
  CX_ASSERT (g_initialised);
  
  glViewport (0, 0, width, height);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

void cx_gdi_clear (const cx_colour *colour)
{
  CX_ASSERT (g_initialised);
  CX_ASSERT (colour);
  
  glClearColor (colour->r, colour->g, colour->b, colour->a);
  glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

void cx_gdi_enable_z_write (bool enable)
{
  glDepthMask (enable);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

void cx_gdi_set_blend_mode (cx_gdi_blend_mode src, cx_gdi_blend_mode dest)
{
  CX_ASSERT ((src > CX_GDI_BLEND_MODE_INVALID) && (src < CX_NUM_GDI_BLEND_MODES));
  CX_ASSERT ((dest > CX_GDI_BLEND_MODE_INVALID) && (dest < CX_NUM_GDI_BLEND_MODES));
  
  GLenum srcMode = g_openglBlendModes [src];
  GLenum destMode = g_openglBlendModes [dest];
  
  glBlendFunc (srcMode, destMode);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

void cx_gdi_set_renderstate (cx_gdi_renderstate renderstate)
{
  //CX_ASSERT (renderstate != CX_GDI_RENDER_STATE_NONE);
  
  g_activeRenderstate = renderstate;
  
  if (renderstate & CX_GDI_RENDER_STATE_CULL)
  {
    //glCullFace (GL_FRONT);
    glEnable (GL_CULL_FACE);
  }
  else 
  {
    glDisable (GL_CULL_FACE);
  }

  if (renderstate & CX_GDI_RENDER_STATE_DEPTH_TEST)
  {
    glEnable (GL_DEPTH_TEST);
  }
  else 
  {
    glDisable (GL_DEPTH_TEST);
  }
  
  if (renderstate & CX_GDI_RENDER_STATE_BLEND)
  {
    glEnable (GL_BLEND);
  }
  else 
  {
    glDisable (GL_BLEND);
  } 
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

void cx_gdi_get_renderstate (cx_gdi_renderstate *renderstate)
{
  *renderstate = g_activeRenderstate;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

void cx_gdi_unbind_all_buffers (void)
{
  glBindVertexArrayOES (0);
  glBindBuffer (GL_ARRAY_BUFFER, 0);
  glBindBuffer (GL_ELEMENT_ARRAY_BUFFER, 0);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

void _cx_gdi_assert_no_errors (void)
{
#if CX_GDI_DEBUG
  GLenum error = glGetError ();
  
  switch (error) 
  {
    case GL_NO_ERROR:           { break; }
    case GL_INVALID_ENUM:       { CX_LOG_CONSOLE (1, "GL_INVALID_ENUM"); break; }
    case GL_INVALID_VALUE:      { CX_LOG_CONSOLE (1, "GL_INVALID_VALUE"); break; }
    case GL_INVALID_OPERATION:  { CX_LOG_CONSOLE (1, "GL_INVALID_OPERATION"); break; }
    case GL_OUT_OF_MEMORY:      { CX_LOG_CONSOLE (1, "GL_OUT_OF_MEMORY"); break; }
    default:                    { CX_LOG_CONSOLE (1, "UNKNOWN GL ERROR"); break; }
  }
 
  CX_ASSERT (error == GL_NO_ERROR);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

static void cx_gdi_init_extensions (void)
{
#if CX_GDI_DEBUG_LOG_ENABLED
  struct graphics_info
  {
    GLenum type;
    const char *name;
  };
  
  struct graphics_info info [] =
  {
    { GL_MAX_VERTEX_ATTRIBS, "GL_MAX_VERTEX_ATTRIBS" },
    { GL_MAX_VERTEX_UNIFORM_VECTORS, "GL_MAX_VERTEX_UNIFORM_VECTORS" },
    { GL_MAX_VARYING_VECTORS, "GL_MAX_VARYING_VECTORS" },
    { GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS, "GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS" },
    { GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS, "GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS"},
    { GL_MAX_TEXTURE_IMAGE_UNITS, "GL_MAX_TEXTURE_IMAGE_UNITS" },
    { GL_MAX_TEXTURE_SIZE, "GL_MAX_TEXTURE_SIZE" },
    { GL_DEPTH_BITS, "GL_DEPTH_BITS" },
    { GL_STENCIL_BITS, "GL_STENCIL_BITS" },
    { GL_NUM_COMPRESSED_TEXTURE_FORMATS, "GL_NUM_COMPRESSED_TEXTURE_FORMATS" }
  };
  
  int numInfo = sizeof (info) / sizeof (struct graphics_info);
  
  for (int i = 0; i < numInfo; ++i)
  {
    const char *str = info [i].name;
    GLenum type = info [i].type;
    
    GLint val;
    glGetIntegerv (type, &val);
   
    CX_LOG_CONSOLE (CX_GDI_DEBUG_LOG_ENABLED, "%s: %d", str, val);
    CX_REF_UNUSED (str);
  }
  
  // compressed texture support
  
  GLint numCompressedTextures = 0;
  glGetIntegerv (GL_NUM_COMPRESSED_TEXTURE_FORMATS, &numCompressedTextures);
  
  if (numCompressedTextures > 0)
  {
    GLint *compressedFormats = (GLint *) cx_malloc (sizeof (GLint) * numCompressedTextures);
    glGetIntegerv (GL_COMPRESSED_TEXTURE_FORMATS, compressedFormats);
    
    CX_LOG_CONSOLE (CX_GDI_DEBUG_LOG_ENABLED, "cx_gdi: Supported compressed texture formats:");
    
    for (int j = 0; j < numCompressedTextures; ++j)
    {
      GLenum format = (GLenum) compressedFormats [j];
    
      const char *formatStr = NULL;
      
      switch (format)
      {
        case GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG:  { formatStr = "cx_gdi: GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG"; break; }
        case GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG:  { formatStr = "cx_gdi: GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG"; break; }
        case GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: { formatStr = "cx_gdi: GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG"; break; }
        case GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: { formatStr = "cx_gdi: GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG"; break; }
        default:                                  { formatStr = "cx_gdi: GL_COMPRESSED_FORMAT_UNKNOWN!"; break; }
      }
                                                    
      CX_LOG_CONSOLE (CX_GDI_DEBUG_LOG_ENABLED, "%s", formatStr);
      CX_REF_UNUSED (formatStr);
    }
    
    cx_free (compressedFormats);
  }
#endif
  
  
  // supported extensions
  
  const char *supportedExtensions = (const char *) glGetString (GL_EXTENSIONS);
  CX_LOG_CONSOLE (CX_GDI_DEBUG_LOG_ENABLED, "%s", supportedExtensions);
  CX_REF_UNUSED (supportedExtensions);
  
  char *extensionsArray [512];
  
  cxu32 numExtensions = cx_str_explode (extensionsArray, 512, supportedExtensions, ' ');
  
  if (numExtensions > 0)
  {
    cxu32 queryCount = sizeof (g_extensionInfoArray) / sizeof (cx_gdi_extension_info);
    
    for (cxu32 q = 0; q < queryCount; ++q)
    {
      const char *qry = g_extensionInfoArray [q].name;
      CX_ASSERT (qry);
      
      for (cxu32 e = 0; e < numExtensions; ++e)
      {
        const char *ext = extensionsArray [e];
        CX_ASSERT (ext);
      
        CX_LOG_CONSOLE (CX_GDI_DEBUG_LOG_ENABLED, "cx_gdi: supported extension: %s", ext);
        
        if (strcmp (ext, qry) == 0)
        {
          g_extensionInfoArray [q].supported = true;
        }
      }
    }
    
    
    for (cxu32 e = 0; e < numExtensions; ++e)
    {
      cx_free (extensionsArray [e]);
    }
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

