//
//  worker.c
//  earthnews
//
//  Created by Ubaka Onyechi on 18/08/2012.
//  Copyright (c) 2012 uonyechi.com. All rights reserved.
//

#include "worker.h"
#include "../engine/cx_engine.h"

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

typedef struct task_t
{
  task_id id;
  task_func func;
  void *userdata;
  task_status *status;
  struct task_t *next;
} task_t;

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

#define TASK_MAX_COUNT (16)

static task_t *g_taskPoolArray = NULL;

static task_t *g_taskFreeList = NULL;
static task_t *g_taskBusyList = NULL;
static int g_taskFreeListCount = 0;
static int g_taskBusyListCount = 0;

static cx_thread *g_thread = NULL;
static cx_thread_monitor g_threadMonitor;
static cx_thread_mutex g_sharedDataMutex;

static task_id g_taskIdFactory = 0;

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

static task_t *task_list_insert_back (task_t *head, task_t *task, int *count)
{
  if (head)
  {
    task_t *curr = head;
    
    while (curr && curr->next)
    {
      curr = curr->next;
    }
    
    curr->next = task;
  }
  else
  {
    head = task;
  }

  ++(*count);
  
  return head;
}

static task_t *task_list_pop_front (task_t *head, task_t **front, int *count)
{
  *front = head;

  if (head)
  {
    head = head->next;

    --(*count);
  }
  
  return head;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

static cx_thread_exit_status worker_thread_func (void *data)
{
  cx_thread_exit_status exitStatus = CX_THREAD_EXIT_STATUS_SUCCESS;
  
  while (1)
  {
    cx_thread_monitor_wait (&g_threadMonitor);
    
    cx_thread_mutex_lock (&g_sharedDataMutex);
    
    task_t *task = NULL;
    
    g_taskBusyList = task_list_pop_front (g_taskBusyList, &task, &g_taskBusyListCount);
    
    while (task)
    {
      cx_thread_mutex_unlock (&g_sharedDataMutex);
      
      task->func (task->userdata);
    
      if (task->status)
      {
        *task->status = TASK_STATUS_COMPLETE;
      }
      
      task->func = NULL;
      task->userdata = NULL;
      task->next = NULL;
      
      cx_thread_mutex_lock (&g_sharedDataMutex);
      
      g_taskFreeList = task_list_insert_back (g_taskFreeList, task, &g_taskFreeListCount);
      g_taskBusyList = task_list_pop_front (g_taskBusyList, &task, &g_taskBusyListCount);
    }
    
    cx_thread_mutex_unlock (&g_sharedDataMutex);
  }
  
  return exitStatus;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

void worker_init (void)
{
  g_taskPoolArray = (task_t *) cx_malloc (sizeof (task_t) * TASK_MAX_COUNT);
  
  unsigned int i;
  
  for (i = 0; i < TASK_MAX_COUNT; ++i)
  {
    task_t *task = &g_taskPoolArray [i];
    
    g_taskFreeList = task_list_insert_back (g_taskFreeList, task, &g_taskFreeListCount);
  }
  
  cx_thread_mutex_init (&g_sharedDataMutex);
  
  cx_thread_monitor_init (&g_threadMonitor);
  
  g_thread = cx_thread_create ("earthnews worker thread", CX_THREAD_TYPE_JOINABLE, worker_thread_func, NULL);
  
  cx_thread_start (g_thread);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

void worker_deinit (void)
{
  cx_thread_destroy (g_thread);
  
  cx_thread_monitor_deinit (&g_threadMonitor);
  
  cx_thread_mutex_deinit (&g_sharedDataMutex);
  
  cx_free (g_taskPoolArray);
  
  g_thread = NULL;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

void worker_update (void)
{
  CX_FATAL_ASSERT (g_thread);
  
  cx_thread_mutex_lock (&g_sharedDataMutex);
  
  if (g_taskBusyListCount > 0)
  {
    cx_thread_monitor_signal (&g_threadMonitor);
  }
  
  cx_thread_mutex_unlock (&g_sharedDataMutex);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

task_id worker_add_task (task_func func, void *userdata, task_status *status)
{
  CX_FATAL_ASSERT (g_thread);
  CX_ASSERT (func);
  
  task_id taskId = TASK_ID_INVALID;
  
  task_t *task = NULL;
  
  cx_thread_mutex_lock (&g_sharedDataMutex);
  
  g_taskFreeList = task_list_pop_front (g_taskFreeList, &task, &g_taskFreeListCount);
  
  if (task)
  {
    if (status)
    {
      *status = TASK_STATUS_INPROGRESS;
    }
    
    task->id = g_taskIdFactory++;
    task->func = func;
    task->userdata = userdata;
    task->status = status;
    
    g_taskBusyList = task_list_insert_back (g_taskBusyList, task, &g_taskBusyListCount);
    
    taskId = task->id;
  }
  else
  {
    if (status)
    {
      *status = TASK_STATUS_INVALID;
    }
  }
  
  cx_thread_mutex_unlock (&g_sharedDataMutex);
  
  return taskId;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
