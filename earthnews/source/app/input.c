//
//  input.c
//  earthnews
//
//  Created by Ubaka Onyechi on 16/12/2012.
//  Copyright (c) 2012 uonyechi.com. All rights reserved.
//

#include "input.h"

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

// for earthnews, the cache sizes will never exceed 1
#define INPUT_MAX_TOUCH_EVENTS_CACHE_SIZE (4)   
#define INPUT_MAX_GESTURE_EVENTS_CACHE_SIZE (4)

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

static bool g_initialised = false;
static cx_list2 g_touchEventCallbacks [NUM_INPUT_TOUCH_TYPES];
static cx_list2 g_gestureEventCallbacks [NUM_INPUT_GESTURE_TYPES];

static input_touch_event g_touchEventsCache [INPUT_MAX_TOUCH_EVENTS_CACHE_SIZE];
static unsigned int g_touchEventsCount = 0;

static input_gesture_event g_gestureEventsCache [INPUT_MAX_GESTURE_EVENTS_CACHE_SIZE];
static unsigned int g_gestureEventsCount = 0;

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

static void input_process_cached_events (void);
static void input_clear_cached_events (void);

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

bool input_init (void)
{
  CX_ASSERT (!g_initialised);
  
  for (int i = 0; i < NUM_INPUT_TOUCH_TYPES; ++i)
  {
    cx_list2 *list = &g_touchEventCallbacks [i];
    cx_list2_init (list);
  }
  
  for (int i = 0; i < NUM_INPUT_TOUCH_TYPES; ++i)
  {
    cx_list2 *list = &g_gestureEventCallbacks [i];
    cx_list2_init (list);
  }
  
  g_touchEventsCount = 0;
  g_gestureEventsCount = 0;
  g_initialised = true;
  
  return true;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

bool input_deinit (void)
{
  CX_ASSERT (g_initialised);
  
  for (int i = 0; i < NUM_INPUT_TOUCH_TYPES; ++i)
  {
    cx_list2 *list = &g_touchEventCallbacks [i];
    cx_list2_deinit (list);
  }

  for (int i = 0; i < NUM_INPUT_TOUCH_TYPES; ++i)
  {
    cx_list2 *list = &g_gestureEventCallbacks [i];
    cx_list2_deinit (list);
  }
  
  g_initialised = false;
  
  return true;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

void input_update (void)
{
  CX_ASSERT (g_initialised);
  
  input_process_cached_events ();
  input_clear_cached_events ();
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

void input_register_touch_event_callback (input_touch_type type, input_touch_event_callback fn)
{
  CX_ASSERT (g_initialised);
  CX_ASSERT ((type > INPUT_TOUCH_TYPE_INVALID) && (type < NUM_INPUT_TOUCH_TYPES));
  CX_ASSERT (!cx_list2_exists (&g_touchEventCallbacks [type], fn));
  
  cx_list2_insert_back (&g_touchEventCallbacks [type], fn);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

void input_register_gesture_event_callback (input_gesture_type type, input_gesture_event_callback fn)
{
  CX_ASSERT (g_initialised);
  CX_ASSERT ((type > INPUT_GESTURE_TYPE_INVALID) && (type < NUM_INPUT_GESTURE_TYPES));
  CX_ASSERT (!cx_list2_exists (&g_gestureEventCallbacks [type], fn));
  
  cx_list2_insert_back (&g_gestureEventCallbacks [type], fn);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

void _input_cache_touch_event (input_touch_type type, float x, float y, float px, float py)
{
  if (g_initialised)
  {
    CX_ASSERT ((type > INPUT_TOUCH_TYPE_INVALID) && (type < NUM_INPUT_TOUCH_TYPES));
    CX_ASSERT (g_touchEventsCount < INPUT_MAX_TOUCH_EVENTS_CACHE_SIZE);
    
    if (g_touchEventsCount < INPUT_MAX_TOUCH_EVENTS_CACHE_SIZE)
    {
      input_touch_event *touchEvent = &g_touchEventsCache [g_touchEventsCount++];
      
      touchEvent->type = type;
      touchEvent->point.x = x;
      touchEvent->point.y = y;
      touchEvent->prevpoint.x = px;
      touchEvent->prevpoint.y = py;
    }
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

void _input_cache_gesture_event (input_gesture_type type, void *gestureData)
{
  if (g_initialised)
  {
    CX_ASSERT ((type > INPUT_GESTURE_TYPE_INVALID) && (type < NUM_INPUT_GESTURE_TYPES));
    CX_ASSERT (g_gestureEventsCount < INPUT_MAX_GESTURE_EVENTS_CACHE_SIZE);
    
    if (g_gestureEventsCount < INPUT_MAX_GESTURE_EVENTS_CACHE_SIZE)
    {    
      input_gesture_event *gestureEvent = &g_gestureEventsCache [g_gestureEventsCount++];
      
      gestureEvent->type = type;
      
      switch (type) 
      {
        case INPUT_GESTURE_TYPE_PINCH: { gestureEvent->data.pinch.factor = *(float *) gestureData; break; }
        default: { break; }
      }
    }
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

static void input_process_cached_events (void)
{
  CX_ASSERT (g_initialised);
  
  if (g_gestureEventsCount > 0)
  {
    g_touchEventsCount = 0;
  }
    
  // gesture events
  
  for (unsigned i = 0, c = g_gestureEventsCount; i < c; ++i)
  {
    const input_gesture_event *gestureEvent = &g_gestureEventsCache [i];
    
    cx_list2 *list = &g_gestureEventCallbacks [gestureEvent->type];
    
    cx_list2_node *cb = list->head;
    
    while (cb)
    {
      CX_ASSERT (cb->data);
      
      input_gesture_event_callback fn = (input_gesture_event_callback) cb->data;
      
      fn (gestureEvent);
      
      cb = cb->next;
    }
  }

  // touch events
  
  for (unsigned i = 0, c = g_touchEventsCount; i < c; ++i)
  {
    const input_touch_event *touchEvent = &g_touchEventsCache [i];
    
    cx_list2 *list = &g_touchEventCallbacks [touchEvent->type];
    
    cx_list2_node *cb = list->head;
    
    while (cb)
    {
      CX_ASSERT (cb->data);
      
      input_touch_event_callback fn = (input_touch_event_callback) cb->data;
      
      fn (touchEvent);
      
      cb = cb->next;
    }
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

static void input_clear_cached_events (void)
{
  CX_ASSERT (g_initialised);
  
  g_touchEventsCount = 0;
  g_gestureEventsCount = 0;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////
